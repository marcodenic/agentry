package registry

import (
	"context"
	"fmt"
	"time"

	"github.com/marcodenic/agentry/api"
)

// RegistryServer implements the registry-related gRPC methods
type RegistryServer struct {
	api.UnimplementedAgentHubServer
	registry  AgentRegistry
	discovery *DiscoveryService
}

// NewRegistryServer creates a new registry server
func NewRegistryServer() *RegistryServer {
	reg := NewInMemoryRegistry(30*time.Second, 60*time.Second)
	discovery := NewDiscoveryService(reg)
	
	return &RegistryServer{
		registry:  reg,
		discovery: discovery,
	}
}

// RegisterAgent registers a new agent with the registry
func (s *RegistryServer) RegisterAgent(ctx context.Context, req *api.RegisterAgentRequest) (*api.Ack, error) {
	if req.AgentId == "" {
		return &api.Ack{Ok: false}, fmt.Errorf("agent ID cannot be empty")
	}
	
	agentInfo := &AgentInfo{
		ID:           req.AgentId,
		Capabilities: req.Capabilities,
		Endpoint:     req.Endpoint,
		Metadata:     req.Metadata,
		SessionID:    req.SessionId,
		Role:         req.Role,
		Version:      req.Version,
		Status:       StatusIdle,
	}
	
	err := s.registry.RegisterAgent(ctx, agentInfo)
	if err != nil {
		return &api.Ack{Ok: false}, err
	}
	
	return &api.Ack{Ok: true}, nil
}

// DeregisterAgent removes an agent from the registry
func (s *RegistryServer) DeregisterAgent(ctx context.Context, req *api.GetAgentRequest) (*api.Ack, error) {
	err := s.registry.DeregisterAgent(ctx, req.AgentId)
	if err != nil {
		return &api.Ack{Ok: false}, err
	}
	
	return &api.Ack{Ok: true}, nil
}

// GetAgent retrieves information about a specific agent
func (s *RegistryServer) GetAgent(ctx context.Context, req *api.GetAgentRequest) (*api.GetAgentResponse, error) {
	agentInfo, err := s.registry.GetAgent(ctx, req.AgentId)
	if err != nil {
		return nil, err
	}
	
	apiAgent := s.toAPIAgentInfo(agentInfo)
	return &api.GetAgentResponse{Agent: apiAgent}, nil
}

// ListAgents returns all registered agents
func (s *RegistryServer) ListAgents(ctx context.Context, req *api.ListAgentsRequest) (*api.ListAgentsResponse, error) {
	var agents []*AgentInfo
	var err error
	
	if len(req.Capabilities) > 0 {
		// Filter by capabilities
		agents, err = s.registry.FindAgents(ctx, req.Capabilities)
	} else {
		// Get all agents
		agents, err = s.registry.ListAllAgents(ctx)
	}
	
	if err != nil {
		return nil, err
	}
	
	// Filter by status if specified
	if len(req.Statuses) > 0 {
		agents = s.filterByStatus(agents, req.Statuses)
	}
	
	// Filter by role if specified
	if req.Role != "" {
		agents = s.filterByRole(agents, req.Role)
	}
	
	// Convert to API format
	apiAgents := make([]*api.AgentInfo, len(agents))
	for i, agent := range agents {
		apiAgents[i] = s.toAPIAgentInfo(agent)
	}
	
	return &api.ListAgentsResponse{Agents: apiAgents}, nil
}

// UpdateAgentStatus updates the status of an agent
func (s *RegistryServer) UpdateAgentStatus(ctx context.Context, req *api.UpdateAgentStatusRequest) (*api.Ack, error) {
	status := registry.AgentStatus(req.Status)
	err := s.registry.UpdateAgentStatus(ctx, req.AgentId, status)
	if err != nil {
		return &api.Ack{Ok: false}, err
	}
	
	return &api.Ack{Ok: true}, nil
}

// UpdateHealth updates health metrics for an agent
func (s *RegistryServer) UpdateHealth(ctx context.Context, req *api.UpdateHealthRequest) (*api.Ack, error) {
	health := &HealthMetrics{
		CPUUsage:       req.Health.CpuUsage,
		MemoryUsage:    req.Health.MemoryUsage,
		TasksCompleted: req.Health.TasksCompleted,
		TasksActive:    int(req.Health.TasksActive),
		ErrorCount:     req.Health.ErrorCount,
		Uptime:         req.Health.UptimeSeconds,
	}
	
	err := s.registry.UpdateAgentHealth(ctx, req.AgentId, health)
	if err != nil {
		return &api.Ack{Ok: false}, err
	}
	
	return &api.Ack{Ok: true}, nil
}

// Heartbeat updates the last seen time for an agent
func (s *RegistryServer) Heartbeat(ctx context.Context, req *api.HeartbeatRequest) (*api.Ack, error) {
	err := s.registry.Heartbeat(ctx, req.AgentId)
	if err != nil {
		return &api.Ack{Ok: false}, err
	}
	
	return &api.Ack{Ok: true}, nil
}

// FindAgents finds the best agents for a given set of requirements
func (s *RegistryServer) FindAgents(ctx context.Context, req *api.FindAgentsRequest) (*api.FindAgentsResponse, error) {
	opts := &DiscoveryOptions{
		RequiredCapabilities:  req.RequiredCapabilities,
		PreferredCapabilities: req.PreferredCapabilities,
		ExcludeAgents:        req.ExcludeAgents,
		MaxResults:           int(req.MaxResults),
		SortBy:               req.SortBy,
	}
	
	// Convert status strings to AgentStatus
	if len(req.RequiredStatus) > 0 {
		opts.RequiredStatus = make([]registry.AgentStatus, len(req.RequiredStatus))
		for i, status := range req.RequiredStatus {
			opts.RequiredStatus[i] = registry.AgentStatus(status)
		}
	}
	
	scores, err := s.discovery.FindBestAgents(ctx, opts)
	if err != nil {
		return nil, err
	}
	
	// Convert to API format
	apiScores := make([]*api.AgentScore, len(scores))
	for i, score := range scores {
		apiScores[i] = &api.AgentScore{
			Agent: s.toAPIAgentInfo(score.Agent),
			Score: score.Score,
		}
	}
	
	return &api.FindAgentsResponse{Agents: apiScores}, nil
}

// GetClusterStatus returns overall cluster status information
func (s *RegistryServer) GetClusterStatus(ctx context.Context, req *api.GetClusterStatusRequest) (*api.GetClusterStatusResponse, error) {
	clusterStatus, err := s.discovery.GetClusterStatus(ctx)
	if err != nil {
		return nil, err
	}
	
	// Convert status counts to string keys
	statusCounts := make(map[string]int32)
	for status, count := range clusterStatus.StatusCounts {
		statusCounts[string(status)] = int32(count)
	}
	
	// Convert capabilities and roles to int32
	capabilities := make(map[string]int32)
	for cap, count := range clusterStatus.Capabilities {
		capabilities[cap] = int32(count)
	}
	
	roles := make(map[string]int32)
	for role, count := range clusterStatus.Roles {
		roles[role] = int32(count)
	}
	
	apiStatus := &api.ClusterStatus{
		TotalAgents:         int32(clusterStatus.TotalAgents),
		StatusCounts:        statusCounts,
		Capabilities:        capabilities,
		Roles:              roles,
		AverageUptimeSeconds: int64(clusterStatus.AverageUptime.Seconds()),
		TotalTasksCompleted: clusterStatus.TotalTasksCompleted,
		TotalErrors:         clusterStatus.TotalErrors,
		LastUpdated:         clusterStatus.LastUpdated.Unix(),
	}
	
	return &api.GetClusterStatusResponse{Status: apiStatus}, nil
}

// Helper methods

func (s *RegistryServer) toAPIAgentInfo(agent *AgentInfo) *api.AgentInfo {
	return &api.AgentInfo{
		Id:           agent.ID,
		Capabilities: agent.Capabilities,
		Endpoint:     agent.Endpoint,
		Status:       string(agent.Status),
		Metadata:     agent.Metadata,
		LastSeen:     agent.LastSeen.Unix(),
		RegisteredAt: agent.RegisteredAt.Unix(),
		SessionId:    agent.SessionID,
		Role:         agent.Role,
		Version:      agent.Version,
	}
}

func (s *RegistryServer) filterByStatus(agents []*AgentInfo, statuses []string) []*AgentInfo {
	statusMap := make(map[string]bool)
	for _, status := range statuses {
		statusMap[status] = true
	}
	
	var filtered []*AgentInfo
	for _, agent := range agents {
		if statusMap[string(agent.Status)] {
			filtered = append(filtered, agent)
		}
	}
	
	return filtered
}

func (s *RegistryServer) filterByRole(agents []*AgentInfo, role string) []*AgentInfo {
	var filtered []*AgentInfo
	for _, agent := range agents {
		if agent.Role == role {
			filtered = append(filtered, agent)
		}
	}
	
	return filtered
}

// GetRegistry returns the underlying registry for testing or advanced usage
func (s *RegistryServer) GetRegistry() registry.AgentRegistry {
	return s.registry
}

// GetDiscovery returns the underlying discovery service
func (s *RegistryServer) GetDiscovery() *registry.DiscoveryService {
	return s.discovery
}

// Close closes the registry server and its resources
func (s *RegistryServer) Close() error {
	return s.registry.Close()
}
